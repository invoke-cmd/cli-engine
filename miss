param(
[Parameter(Mandatory=$true)]
[string]$BaseFolderPath,

```
[Parameter(Mandatory=$true)]
[string]$OutputLocation
```

)

# Function to get manually installed packages (top-level only, no dependencies)

function Get-ManuallyInstalledPackages {
param([string]$PythonPath)

```
try {
    # Use pip show to get only manually installed packages
    $pipShowOutput = & "$PythonPath" -m pip list --format=json --not-required 2>$null
    if ($LASTEXITCODE -eq 0) {
        return $pipShowOutput | ConvertFrom-Json
    }
    return @()
}
catch {
    return @()
}
```

}

# Function to get Python version

function Get-PythonVersion {
param([string]$PythonPath)

```
try {
    $versionOutput = & "$PythonPath" --version 2>$null
    if ($LASTEXITCODE -eq 0) {
        return $versionOutput -replace "Python ", ""
    }
    return "Unknown"
}
catch {
    return "Unknown"
}
```

}

# Function to detect environment type and name

function Get-EnvironmentInfo {
param([string]$FolderPath)

```
$envName = Split-Path $FolderPath -Leaf
$envType = "Unknown"

# Check for conda environment
if (Test-Path (Join-Path $FolderPath "conda-meta")) {
    $envType = "Conda"
}
# Check for venv/virtualenv
elseif (Test-Path (Join-Path $FolderPath "pyvenv.cfg")) {
    $envType = "venv/virtualenv"
}
# Check for pipenv
elseif (Test-Path (Join-Path $FolderPath "Pipfile")) {
    $envType = "Pipenv"
}
# Check for poetry
elseif (Test-Path (Join-Path $FolderPath "pyproject.toml")) {
    $envType = "Poetry"
}

return @{
    Name = $envName
    Type = $envType
}
```

}

# Main script execution

Write-Host “Starting Python environment scan…” -ForegroundColor Green
Write-Host “Base folder: $BaseFolderPath” -ForegroundColor Yellow
Write-Host “Output location: $OutputLocation” -ForegroundColor Yellow

# Validate base folder exists

if (-not (Test-Path $BaseFolderPath)) {
Write-Error “Base folder path does not exist: $BaseFolderPath”
exit 1
}

# Create output directory if it doesn’t exist

if (-not (Test-Path $OutputLocation)) {
New-Item -ItemType Directory -Path $OutputLocation -Force | Out-Null
}

# Get machine name and timestamp

$machineName = $env:COMPUTERNAME
$timestamp = Get-Date -Format “yyyyMMdd_HHmmss”
$outputFileName = “${machineName}_${timestamp}_python_environments.json”
$outputFilePath = Join-Path $OutputLocation $outputFileName

# Initialize results array

$results = @()

# Common Python executable names and paths

$pythonExecutables = @(“python.exe”, “python3.exe”, “python”)
$commonPaths = @(“Scripts”, “bin”, “.”)

# Scan subfolders

Write-Host “Scanning subfolders for Python environments…” -ForegroundColor Green

Get-ChildItem -Path $BaseFolderPath -Directory -Recurse | ForEach-Object {
$subfolderPath = $_.FullName
$relativePath = $subfolderPath.Replace($BaseFolderPath, “”).TrimStart(’')

```
Write-Host "Checking: $relativePath" -ForegroundColor Cyan

# Look for Python executables in common locations
$pythonFound = $false

foreach ($commonPath in $commonPaths) {
    $searchPath = Join-Path $subfolderPath $commonPath
    if (Test-Path $searchPath) {
        foreach ($executable in $pythonExecutables) {
            $pythonPath = Join-Path $searchPath $executable
            if (Test-Path $pythonPath) {
                Write-Host "  Found Python: $pythonPath" -ForegroundColor Green
                
                # Get environment info
                $envInfo = Get-EnvironmentInfo -FolderPath $subfolderPath
                
                # Get Python version
                $pythonVersion = Get-PythonVersion -PythonPath $pythonPath
                
                # Get manually installed packages
                Write-Host "  Getting package list..." -ForegroundColor Yellow
                $packages = Get-ManuallyInstalledPackages -PythonPath $pythonPath
                
                # Create result object
                $result = [PSCustomObject]@{
                    MachineName = $machineName
                    ScanTimestamp = (Get-Date -Format "yyyy-MM-dd HH:mm:ss")
                    FolderPath = $relativePath
                    EnvironmentName = $envInfo.Name
                    EnvironmentType = $envInfo.Type
                    PythonVersion = $pythonVersion
                    PythonExecutablePath = $pythonPath
                    ManuallyInstalledPackages = $packages
                    PackageCount = $packages.Count
                }
                
                $results += $result
                $pythonFound = $true
                Write-Host "  Added environment: $($envInfo.Name) (Python $pythonVersion, $($packages.Count) packages)" -ForegroundColor Green
                break
            }
        }
        if ($pythonFound) { break }
    }
}

if (-not $pythonFound) {
    Write-Host "  No Python executable found" -ForegroundColor Gray
}
```

}

# Export results to JSON

Write-Host “`nExporting results to JSON…” -ForegroundColor Green
Write-Host “Output file: $outputFilePath” -ForegroundColor Yellow

try {
$jsonOutput = $results | ConvertTo-Json -Depth 10
$jsonOutput | Out-File -FilePath $outputFilePath -Encoding UTF8

```
Write-Host "`nScan completed successfully!" -ForegroundColor Green
Write-Host "Found $($results.Count) Python environments" -ForegroundColor Yellow
Write-Host "Results saved to: $outputFilePath" -ForegroundColor Yellow

# Display summary
Write-Host "`nSummary:" -ForegroundColor Cyan
$results | ForEach-Object {
    Write-Host "  - $($_.EnvironmentName): Python $($_.PythonVersion) ($($_.PackageCount) packages)" -ForegroundColor White
}
```

}
catch {
Write-Error “Failed to export results: $_”
exit 1
}

# Optional: Open the output file

$openFile = Read-Host “`nWould you like to open the output file? (y/n)”
if ($openFile -eq ‘y’ -or $openFile -eq ‘Y’) {
Start-Process $outputFilePath
}